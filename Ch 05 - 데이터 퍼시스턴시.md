
**문제 상황**
>노드 고장 발생 → 다른 노드에 파드 생성하면 된다.
>하지만, 해당 노드에 존재하던 데이터는?
>따라서, 클러스터 전체에서 접근할 수 있는 저장소 필요

**해결**
> 쿠버네티스는 스토리지 유형의 리소스 제공


*ref.* [[쿠버네티스-Ch1.pdf#page=146]]

# 쿠버네티스에서 컨테이너 파일 시스템이 구축되는 과정

**구성**
>1. 이미지 레이어 (변경 불가능)
>2. **볼륨** 마운트
>	+ 비밀 값 & 컨피그 맵
>	+ 볼륨
>3. 기록 가능 레이어 → 컨테이너와 생애주기 동일

*ref.* [[쿠버네티스-Ch1.pdf#page=150]]

## 볼륨

> **볼륨** → 컨피그맵 & 비밀 값과 마찬가지로 마운트 해서 사용

### 공 디렉터리 (emptyDir) 볼륨

> + 컨테이너 안에서 빈 디렉터리로 초기화 되는 유형의 볼륨
> + 이미지나 컨테이너 레이어에 속하지 않는다.

![[공디렉터리.png]]
**특징**
> + 공디렉터리 볼륨에 저장된 데이터 → 대체 컨테이너가 데이터 이어받을 수 있다.
> + 임시 저장 목적이라면 모든 애플리케이션에서 사용가능 → **로컬 캐시에 적합**하다.
> + 파드와 생애주기 동일 (컨테이너와 파드의 차이를 기억하자.) → 파드가 대체되어 새 파드를 만들면 처음 상태인 빈 디렉터리가 된다.
> ```
> 내 착각)
> emptyDir은 파드 수준의 스토리지다. 즉, 컨테이너가 대체 되더라도 emptyDir은 유지가 된다.
> 하지만, 파드가 삭제되면 emptyDir 또한 삭제된다.
> 파드에는 여러 컨테이너가 들어갈 수 있다는 것을 기억하자. 파드 수준과 컨테이너 수준은 다르다.
> ```

*ref.* [[쿠버네티스-Ch1.pdf#page=150]]


### 호스트경로(HostPath) 볼륨

> + 공디렉터리 볼륨보다 더 오래 유지
> + 노드의 디스크를 가리키는 볼륨
> + 파드에 정의되며 컨테이너 파일 시스템에 마운트되는 형태

*ref.* [[쿠버네티스-Ch1.pdf#page=156]]

![[호스트 패스 볼륨.png]]

**한계**
> 1. 노드에 물리적으로 기록 →  데이터 유지를 위해 파드가 같은 노드에 배치
> 2. 보안 문제 → 컨테이너에 침투하면, 디스크 전체를 장악할 수 있다. (노드의 디스크와 연결되어있다.)

Cmd **보안 문제가 있는 호스트 패스 볼륨**
*ref.* [[쿠버네티스-Ch1.pdf#page=158]] → 해결 :: [[쿠버네티스-Ch1.pdf#page=160]]


### 영구볼륨 (PV) & 영구볼륨 클레임 (PVC)

**영구 볼륨** (PV) 
> 전체 클러스터에서 접근 가능 but 한 노드에만 볼륨 존재
> 따라서, 

*ref.* [[쿠버네티스-Ch1.pdf#page=163]]

**영구 볼륨 클레임(PVC)**
> + 파드는 영구 볼륨 클레임을 이용해서 영구 볼륨 사용 요청
> + 파드가 사용하는 스토리지의 추상
> + PV - PVC 는 1:1 관계 → 영구 볼륨 클레임 사용을 위해 영구 볼륨과 먼저 연결되어야 한다. 

*ref.* [[쿠버네티스-Ch1.pdf#page=165]]

![[PVC 확인.png]]


### 영구볼륨 (PV) & 영구볼륨 클레임 (PVC) - 동적 볼륨 프로비저닝

> PVC만 생성 → 그에 맞는 PV는 동적으로 생성

**사용법**
> PVC에서 사용할 스토리지 유형만 정의하면 된다.
> 정의하지 않는다면 기본 유형이 사용된다.
> 
> 도커 데스크탑 → 호스트 경로 볼륨
> 
> **스토리지 유형 설정**
> + **provisioner** → 필요 시 영구 볼륨을 만드는 주체
> + **reclaimPolicy** → 클레임 삭제 시 남은 볼륨 처리 방법 결정
> + **volumeBindingMode** → 영구 볼륨 클레임 생성 시, 영구 볼륨 생성 및 연결 시점 결정
> 


*ref.* [[쿠버네티스-Ch1.pdf#page=173]]